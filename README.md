# Cadavre Exquis - Exquisite Corpse
Project for the course "Digital Creativity"
Autumn 2024

This repository allows to generates images based on random prompts. It is a free adaptation of the game "Exquisite Corpse" invented by the Surrealist around 1925. The images are generated iteratively and can be brought together in a .gif, merged picture or a video.

## Libraries
All libraries necessary are installed in the first cell of the notebook.

+ controlnet_aux
+ diffusers accelerate transformers
+ nltk
+ nltk.downloader averaged_perceptron_tagger
+ random
+ torch torchvision
+ transformers

## Prompt generation
There are three types of prompt generation available.
1. PromptType.CONCRETE selects random nouns from a list of concrete words generated by ChatGPT. These words are easier to represent for the image generation models.
2. PromptType.WORDNET selects random nouns from the Wordnet corpus.
3. PromptType.AUSTEN selects random words from the book "Emma", written by Jane Austen. Other corpus can be used by replacing `book_complete = gutenberg.words('austen-emma.txt')` by another text available in the [Gutenberg ebooks](https://www.gutenberg.org/). This prompt generates an adjective, a noun, a verb, an adjective, a noun. This sequence equals a length of 1.


The function `generate_prompt(prompt_type, length)` generates all three types of prompt (Concrete, Wordnet and Austen), with the wanted length. Since the function refers to other functions and libraries, all the previous cells must be ran for the function to work. The prompt types are encapsulated in the Enum "PromptType".


### Examples
`prompt0 = generate_prompt(PromptType.CONCRETE,2)`\
`prompt1 = generate_prompt(PromptType.WORDNET, 2)`\
`prompt2 = generate_prompt(PromptType.AUSTEN, 2)`\
`print(f'Concrete prompt: {prompt0}')`\
`print(f'Wordnet prompt: {prompt1}')`\
`print(f'Austen prompt: {prompt2}')`

Output:

Concrete prompt: ['file folder', 'open sign']
Wordnet prompt: ['holding_pattern', 'tannin']
Austen prompt: ['poor', 'opinions', 'say', 'near', 'letter', 'cold', 'comfort', 'want', 'sub', 'sort']

## Image generation
There are three types of image generation available.
1. `gif_pipeline(prompt)` generates a 1024x1024 image per word of the prompt. The generated image is used as input of the next iteration. Each picture is saved and a .gif is created with all pictures.
2. `extend_pipeline(prompt)` generates a 1024x1024 image per word of the prompt. The generated image is cropped, the crop is extended to the 1024x1024 size and used as input of the next iteration. Each picture is saved and all pictures are merged into one from format 1024x(1024* prompt's length).
+ The function `add_text_to_image(image_path, text)` adds the title of the image on it, to facilitate the understanding of the gif. It **overwrites** the original filename.
4. `inpainting_pipeline(prompt)` generate a 1024x1024 image per word of the prompt. The generated image is copied smaller and pasted on itself. A mask covering almost all the small image is created. This ensures that the small image is not changed. The part which is not masked will be extended (inpainting) with the word prompt. Each picture is saved and the pipeline returns one image containing the previous images in its center. A video can be created with the delivered images with the functions `create_zoom_video(inpainting_filenames, 'inpainting_car_puzzle.mp4', zoom_factor=1.2, duration_per_image=0.8)` or `generate_zoom_video(image_folder, output_file, zoom_factor=0.05, duration_per_image=1)`.

All three pipelines deliver the first image with the function `first_img(word)`.
General notes, the pictures can be manipulated as variable or opened from their filenames.

### Parameters of the image generation
+ The prompt emphasizes the generated word with "++". It uses a positive and negative prompt to ensure good quality and graphical images.
+ The guidance scale adjusts how closely the image must match the prompt.
+ The strength adjusts how much the original image must be preserved.

### Example
`img2img_pipe(
            # Uncomment for sliding window:
            #prompt= (words[i]+ words[i+1] + words[i+2])+ '++' + positive_prompt,
            prompt= (words[i]+ '++' + positive_prompt,
            negative_prompt=negative_prompt,
            image=current_image, 
            strength=strength, # How much the original image is preserved
            guidance_scale=guidance_scale # How closely the image should match the prompt
        ).images[0]`

Examples of output are available in the repository.
